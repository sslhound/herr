package main

import (
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"
)

var (
	codeCharacters = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
)

type sourcesFlag []string

func (i *sourcesFlag) String() string {
	return strings.Join(*i, ",")
}

func (i *sourcesFlag) Set(value string) error {
	*i = append(*i, value)
	return nil
}

type errorInfo struct {
	Code        uint
	Prefix      string
	Label       string
	Description string
	Source      string
	ParentLabel string
}

// This was copied from https://golang.org/pkg/sort/ and modified.

type lessFunc func(p1, p2 *errorInfo) bool

type multiSorter struct {
	errors []errorInfo
	less   []lessFunc
}

func (ms *multiSorter) Sort(errors []errorInfo) {
	ms.errors = errors
	sort.Sort(ms)
}

func OrderedBy(less ...lessFunc) *multiSorter {
	return &multiSorter{
		less: less,
	}
}

func (ms *multiSorter) Len() int {
	return len(ms.errors)
}

func (ms *multiSorter) Swap(i, j int) {
	ms.errors[i], ms.errors[j] = ms.errors[j], ms.errors[i]
}

func (ms *multiSorter) Less(i, j int) bool {
	p, q := &ms.errors[i], &ms.errors[j]
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			return true
		case less(q, p):
			return false
		}
	}
	return ms.less[k](p, q)
}

func sortByPrefix(e1, e2 *errorInfo) bool {
	return e1.Prefix < e2.Prefix
}

func sortByLabel(e1, e2 *errorInfo) bool {
	return e1.Label < e2.Label
}

func sortByCode(e1, e2 *errorInfo) bool {
	return e1.Code < e2.Code
}

func main() {
	var sources sourcesFlag
	var pkg string
	var out string
	var skipValidate bool
	var lineNumbersMustMatch bool
	var testOut string
	var locale string
	var localeOut string

	flag.BoolVar(&skipValidate, "skip-validate", false, "Skip validation of sources.")
	flag.StringVar(&pkg, "package", "errors", "The package of the source file(s).")
	flag.StringVar(&out, "out", "generated.go", "The name of the source file generated by the program.")
	flag.Var(&sources, "source", "The source file to read errors from.")
	flag.BoolVar(&lineNumbersMustMatch, "match-line-numbers", false, "Line numbers must batch codes in packages.")
	flag.StringVar(&testOut, "test-out", "generated_test.go", "The name of the test source file generated by the program.")
	flag.StringVar(&locale, "locale", "en", "The locale of the content.")
	flag.StringVar(&localeOut, "locale-out", "", "The name of the messages json file generated by the program.")

	flag.Parse()

	var errors []errorInfo
	allErrors := map[string]errorInfo{}

	for _, source := range sources {
		sourceErrors, err := collectErrors(source, lineNumbersMustMatch)
		if err != nil {
			log.Fatalf("error processing source %s: %v\n", source, err)
		}

		for _, sourceError := range sourceErrors {

			if !skipValidate {
				foundErr, ok := allErrors[sourceError.Serialized()]
				if ok {
					panic(fmt.Sprintf("Duplicate error found: %s[%s-%d] %s[%s-%d]",
						foundErr.Source, foundErr.Prefix, foundErr.Code,
						sourceError.Source, sourceError.Prefix, sourceError.Code,
					))
				}
				allErrors[sourceError.Serialized()] = sourceError
			}

			errors = append(errors, sourceError)
		}
	}

	OrderedBy(sortByPrefix, sortByCode).Sort(errors)
	if err := writeGeneratedSource(out, pkg, errors); err != nil {
		panic(err)
	}
	if len(testOut) > 0 {
		if err := writeGeneratedSourceTest(testOut, pkg, errors); err != nil {
			panic(err)
		}
	}
	if len(localeOut) > 0 {
		if err := writeMessageJson(localeOut, locale, errors); err != nil {
			panic(err)
		}
	}
}

func collectErrors(source string, lineNumbersMustMatch bool) ([]errorInfo, error) {
	var errors []errorInfo

	reader, err := os.Open(source)
	if err != nil {
		return nil, err
	}

	csvReader := csv.NewReader(reader)
	csvReader.Comment = '#'
	csvReader.TrimLeadingSpace = true
	csvReader.FieldsPerRecord = -1

	lineNumber := 0

	for {
		record, err := csvReader.Read()
		lineNumber = lineNumber + 1
		if err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		if len(record) < 4 {
			return nil, fmt.Errorf("invalid record %d: %s", lineNumber, strings.Join(record, ","))
		}

		code, err := strconv.Atoi(strings.TrimSpace(record[0]))
		if err != nil {
			return nil, fmt.Errorf("invalid record %d: %s", lineNumber, strings.Join(record, ","))
		}

		if lineNumbersMustMatch && code != lineNumber {
			return nil, fmt.Errorf("line number and record code do not match: %d != %d", lineNumber, code)
		}

		var parentLabel string
		if len(record) == 5 {
			parentLabel = record[4]
		}

		errors = append(errors, errorInfo{
			Code:        uint(code),
			Prefix:      strings.TrimSpace(record[1]),
			Label:       strings.TrimSpace(record[2]),
			Description: strings.TrimSpace(record[3]),
			Source:      source,
			ParentLabel: parentLabel,
		})

	}

	return errors, nil
}

func writeGeneratedSource(out, pkg string, errors []errorInfo) error {
	dest := os.Stdout
	if out != "stdout" {
		var err error
		dest, err = os.Create(out)
		if err != nil {
			return err
		}
		defer func() {
			if closeErr := dest.Close(); closeErr != nil {
				log.Println("error closing source file", out, ":", closeErr.Error())
			}
		}()
	}

	return packageTemplate.Execute(dest, struct {
		Package   string
		Timestamp time.Time
		Codes     []errorInfo
	}{
		Package:   pkg,
		Timestamp: time.Now(),
		Codes:     errors,
	})
}

func writeGeneratedSourceTest(out, pkg string, errors []errorInfo) error {
	dest := os.Stdout
	if out != "stdout" {
		var err error
		dest, err = os.Create(out)
		if err != nil {
			return err
		}
		defer func() {
			if closeErr := dest.Close(); closeErr != nil {
				log.Println("error closing source file", out, ":", closeErr.Error())
			}
		}()
	}

	return testTemplate.Execute(dest, struct {
		Package   string
		Timestamp time.Time
		Codes     []errorInfo
	}{
		Package:   pkg,
		Timestamp: time.Now(),
		Codes:     errors,
	})
}

func writeMessageJson(out, locale string, errors []errorInfo) error {
	dest := os.Stdout
	if out != "stdout" {
		var err error
		dest, err = os.Create(out)
		if err != nil {
			return err
		}
		defer func() {
			if closeErr := dest.Close(); closeErr != nil {
				log.Println("error closing source file", out, ":", closeErr.Error())
			}
		}()
	}

	type message struct {
		Locale  string `json:"locale"`
		Key     string `json:"key"`
		Message string `json:"trans"`
	}
	var messages []message
	for _, errInfo := range errors {
		messages = append(messages, message{
			Locale:  locale,
			Key:     errInfo.Serialized(),
			Message: errInfo.Description,
		})
	}
	data, err := json.MarshalIndent(messages, "", "\t")
	if err != nil {
		return err
	}
	_, err = dest.Write(data)
	return err
}

func (e errorInfo) Serialized() string {
	return fmt.Sprintf("%s%s", e.Prefix, SerializeCode(e.Code))
}

// SerializeCode serializes a number into a english-friendly string.
func SerializeCode(code uint) string {
	if code < uint(len(codeCharacters)) {
		return Left(string(codeCharacters[code]), 8, string(codeCharacters[0]))
	}
	places := make([]string, 50)
	num := int(code)
	place := 0
	for {
		remainder := num % len(codeCharacters)
		digit := string(codeCharacters[remainder])
		places[place] = digit
		place++
		num = num / len(codeCharacters)
		if num < 1 {
			break
		}
	}
	for i, j := 0, len(places)-1; i < j; i, j = i+1, j-1 {
		places[i], places[j] = places[j], places[i]
	}
	return Left(strings.Join(places, ""), 8, string(codeCharacters[0]))
}

func times(str string, n int) string {
	if n <= 0 {
		return ""
	}
	return strings.Repeat(str, n)
}

// Left left-pads the string with pad up to len runes
// len may be exceeded if
func Left(str string, length int, pad string) string {
	return times(pad, length-len(str)) + str
}

var packageTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"lower": strings.ToLower,
}).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by herr at {{ .Timestamp }}
package {{ .Package }}

import (
	"fmt"
	"io"
	"path"
	"runtime"
	"strconv"
	"strings"
    go_errors "errors"
)

type CodedError interface {
    Code() int
    Description() string
    Prefix() string
    error
}

{{ range .Codes }}
type {{ .Label }}Error struct {
    Err error
    Stack *stack
}
{{ end }}
{{ range .Codes }}var _ CodedError = {{ .Label }}Error{}
{{ end }}
// ErrorFromCode returns the CodedError for a serialized coded error string. 
func ErrorFromCode(code string) (bool, error) {
    switch code {
{{- range .Codes }}
    case "{{ .Serialized }}":
        return true, {{ .Label }}Error{}
{{- end }}
    default:
        return false, fmt.Errorf("unknown error code: %s", code)
    }
}
{{ range .Codes }}
func New{{ .Label }}Error(err error) error {
{{ if .ParentLabel }}
	return {{ .Label }}Error{ Err: New{{ .ParentLabel }}Error(err), Stack: callers() }
{{ else }}
	return {{ .Label }}Error{ Err: err, Stack: callers() }
{{ end }}
}

func Wrap{{ .Label }}Error(err error) error {
	if err == nil {
		return nil
	}
	return New{{ .Label }}Error(err)
}
{{ end }}{{ range .Codes }}
func (e {{ .Label }}Error) Error() string {
    return "{{ .Serialized }}"
}

func (e {{ .Label }}Error) Unwrap() error {
	return e.Err
}

func (e {{ .Label }}Error) Is(target error) bool {
    t, ok := target.({{ .Label }}Error)
    if !ok {
        return false
    }
    return t.Prefix() == "{{ .Prefix }}" && t.Code() == {{ .Code }}
}

func (e {{ .Label }}Error) Code() int {
    return {{ .Code }}
}

func (e {{ .Label }}Error) Description() string {
    return "{{ .Description }}"
}

func (e {{ .Label }}Error) Prefix() string {
    return "{{ .Prefix }}"
}

func (e {{ .Label }}Error) String() string {
   return "{{ .Serialized }} {{ .Description }}"
}

func (e {{ .Label }}Error)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "{{ .Serialized }}")
	case 'q':
		fmt.Fprintf(s, "%q", "{{ .Serialized }}")
	}
}
{{ end }}

// Frame represents a program counter inside a stack frame.
// For historical reasons if Frame is interpreted as a uintptr
// its value represents the program counter + 1.
type Frame uintptr

// pc returns the program counter for this frame;
// multiple frames may have the same PC value.
func (f Frame) pc() uintptr { return uintptr(f) - 1 }

// file returns the full path to the file that contains the
// function for this Frame's pc.
func (f Frame) file() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	file, _ := fn.FileLine(f.pc())
	return file
}

// line returns the line number of source code of the
// function for this Frame's pc.
func (f Frame) line() int {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return 0
	}
	_, line := fn.FileLine(f.pc())
	return line
}

// name returns the name of this function, if known.
func (f Frame) name() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	return fn.Name()
}

// Format formats the frame according to the fmt.Formatter interface.
//
//    %s    source file
//    %d    source line
//    %n    function name
//    %v    equivalent to %s:%d
//
// Format accepts flags that alter the printing of some verbs, as follows:
//
//    %+s   function name and path of source file relative to the compile time
//          GOPATH separated by \n\t (<funcname>\n\t<path>)
//    %+v   equivalent to %+s:%d
func (f Frame) Format(s fmt.State, verb rune) {
	switch verb {
	case 's':
		switch {
		case s.Flag('+'):
			io.WriteString(s, f.name())
			io.WriteString(s, "\n\t")
			io.WriteString(s, f.file())
		default:
			io.WriteString(s, path.Base(f.file()))
		}
	case 'd':
		io.WriteString(s, strconv.Itoa(f.line()))
	case 'n':
		io.WriteString(s, funcname(f.name()))
	case 'v':
		f.Format(s, 's')
		io.WriteString(s, ":")
		f.Format(s, 'd')
	}
}

// MarshalText formats a stacktrace Frame as a text string. The output is the
// same as that of fmt.Sprintf("%+v", f), but without newlines or tabs.
func (f Frame) MarshalText() ([]byte, error) {
	name := f.name()
	if name == "unknown" {
		return []byte(name), nil
	}
	return []byte(fmt.Sprintf("%s %s:%d", name, f.file(), f.line())), nil
}

// StackTrace is stack of Frames from innermost (newest) to outermost (oldest).
type StackTrace []Frame


// Format formats the stack of Frames according to the fmt.Formatter interface.
//
//    %s	lists source files for each Frame in the stack
//    %v	lists the source file and line number for each Frame in the stack
//
// Format accepts flags that alter the printing of some verbs, as follows:
//
//    %+v   Prints filename, function, and line number for each Frame in the stack.
func (st StackTrace) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		switch {
		case s.Flag('+'):
			for _, f := range st {
				io.WriteString(s, "\n")
				f.Format(s, verb)
			}
		case s.Flag('#'):
			fmt.Fprintf(s, "%#v", []Frame(st))
		default:
			st.formatSlice(s, verb)
		}
	case 's':
		st.formatSlice(s, verb)
	}
}

// formatSlice will format this StackTrace into the given buffer as a slice of
// Frame, only valid when called with '%s' or '%v'.
func (st StackTrace) formatSlice(s fmt.State, verb rune) {
	io.WriteString(s, "[")
	for i, f := range st {
		if i > 0 {
			io.WriteString(s, " ")
		}
		f.Format(s, verb)
	}
	io.WriteString(s, "]")
}

// stack represents a stack of program counters.
type stack []uintptr

func (s *stack) Format(st fmt.State, verb rune) {
	switch verb {
	case 'v':
		switch {
		case st.Flag('+'):
			for _, pc := range *s {
				f := Frame(pc)
				fmt.Fprintf(st, "\n%+v", f)
			}
		}
	}
}

func (s *stack) StackTrace() StackTrace {
	f := make([]Frame, len(*s))
	for i := 0; i < len(f); i++ {
		f[i] = Frame((*s)[i])
	}
	return f
}

func callers() *stack {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(3, pcs[:])
	var st stack = pcs[0:n]
	return &st
}

// funcname removes the path prefix component of a function's name reported by func.Name().
func funcname(name string) string {
	i := strings.LastIndex(name, "/")
	name = name[i+1:]
	i = strings.Index(name, ".")
	return name[i+1:]
}

func ErrorChain(err error) []string {
	var results []string
	if err == nil {
		return results
	}
	depth := 0
	next := err
	for {
		if depth > 10 {
			break
		}
		results = append(results, next.Error())

		next = go_errors.Unwrap(next)
		if next == nil {
			break
		}

		depth = depth + 1
	}
	return results
}
`))

var testTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"lower": strings.ToLower,
}).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by herr at {{ .Timestamp }}
package {{ .Package }}

import (
    "fmt"
	"testing"
	"errors"
)

{{ range .Codes }}
func Test{{ .Label }} (t *testing.T) {
    err1 := New{{ .Label }}Error(nil)
	{
	err1, ok := err1.({{ .Label }}Error)
    if !ok {
		t.Errorf("Assertion failed on {{ .Label }}: %T is not {{ .Label }}Error", err1)
	}
    if err1.Prefix() != "{{ .Prefix }}" {
		t.Errorf("Assertion failed on {{ .Label }}: %s != {{ .Prefix }}", err1.Prefix())
    }
    if err1.Code() != {{ .Code }} {
		t.Errorf("Assertion failed on {{ .Label }}: %d != {{ .Code }}", err1.Code())
    }
    if err1.Description() != "{{ .Description }}" {
		t.Errorf("Assertion failed on {{ .Label }}: %s != {{ .Description }}", err1.Description())
    }
	}

	errNotFound := fmt.Errorf("not found")
	errThingNotFound := fmt.Errorf("thing: %w", errNotFound)
	err2 := New{{ .Label }}Error(errThingNotFound)
	{
    err2, ok := err2.({{ .Label }}Error)
    if !ok {
		t.Errorf("Assertion failed on {{ .Label }}: %T is not {{ .Label }}Error", err2)
	}
	errNestErr2 := fmt.Errorf("oh snap: %w", err2)
    if err2.Code() != {{ .Code }} {
		t.Errorf("Assertion failed on {{ .Label }}: %d != {{ .Code }}", err2.Code())
    }
    if !errors.Is(err2, errNotFound) {
		t.Errorf("Assertion failed on {{ .Label }}: errNotFound not unwrapped correctly")
    }
    if !errors.Is(err2, errThingNotFound) {
		t.Errorf("Assertion failed on {{ .Label }}: errThingNotFound not unwrapped correctly")
    }
    if !errors.Is(err2, {{ .Label }}Error{}) {
		t.Errorf("Assertion failed on {{ .Label }}: {{ .Label }}Error{} not identified correctly")
    }
    if !errors.Is(errNestErr2, {{ .Label }}Error{}) {
		t.Errorf("Assertion failed on {{ .Label }}: {{ .Label }}Error{} not identified correctly")
    }
{{ if .ParentLabel -}}
    if !errors.Is(err2, {{ .ParentLabel }}Error{}) {
		t.Errorf("Assertion failed on {{ .Label }}: {{ .ParentLabel }}Error{} not identified correctly")
    }
{{ end }}
	}
}
{{ end }}

`))
