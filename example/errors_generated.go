// Code generated by go generate; DO NOT EDIT.
// This file was generated by herr at 2020-01-19 14:32:19.364195 -0500 EST m=+0.009997401
package errors

import (
	"fmt"
	"io"
	"path"
	"runtime"
	"strconv"
	"strings"
    go_errors "errors"
)

type CodedError interface {
    Code() int
    Description() string
    Prefix() string
    error
}


type DebugErrorOneError struct {
    Err error
    Stack *stack
}

type DebugErrorTwoError struct {
    Err error
    Stack *stack
}

type DebugErrorThreeError struct {
    Err error
    Stack *stack
}

type InvalidAndroidVersionError struct {
    Err error
    Stack *stack
}

type InvalidAndroidDeviceError struct {
    Err error
    Stack *stack
}

type InvalidIOSDeviceError struct {
    Err error
    Stack *stack
}

var _ CodedError = DebugErrorOneError{}
var _ CodedError = DebugErrorTwoError{}
var _ CodedError = DebugErrorThreeError{}
var _ CodedError = InvalidAndroidVersionError{}
var _ CodedError = InvalidAndroidDeviceError{}
var _ CodedError = InvalidIOSDeviceError{}

// ErrorFromCode returns the CodedError for a serialized coded error string. 
func ErrorFromCode(code string) (bool, error) {
    switch code {
    case "DBGAAAAAAAB":
        return true, DebugErrorOneError{}
    case "DBGAAAAAAAC":
        return true, DebugErrorTwoError{}
    case "DBGAAAAAAAG":
        return true, DebugErrorThreeError{}
    case "MOBANDAAAAAAAE":
        return true, InvalidAndroidVersionError{}
    case "MOBANDAAAAAAAF":
        return true, InvalidAndroidDeviceError{}
    case "MOBIOSAAAAAAAD":
        return true, InvalidIOSDeviceError{}
    default:
        return false, fmt.Errorf("unknown error code: %s", code)
    }
}

func NewDebugErrorOneError(err error) error {

	return DebugErrorOneError{ Err: err, Stack: callers() }

}

func WrapDebugErrorOneError(err error) error {
	if err == nil {
		return nil
	}
	return NewDebugErrorOneError(err)
}

func NewDebugErrorTwoError(err error) error {

	return DebugErrorTwoError{ Err: err, Stack: callers() }

}

func WrapDebugErrorTwoError(err error) error {
	if err == nil {
		return nil
	}
	return NewDebugErrorTwoError(err)
}

func NewDebugErrorThreeError(err error) error {

	return DebugErrorThreeError{ Err: NewDebugErrorTwoError(err), Stack: callers() }

}

func WrapDebugErrorThreeError(err error) error {
	if err == nil {
		return nil
	}
	return NewDebugErrorThreeError(err)
}

func NewInvalidAndroidVersionError(err error) error {

	return InvalidAndroidVersionError{ Err: err, Stack: callers() }

}

func WrapInvalidAndroidVersionError(err error) error {
	if err == nil {
		return nil
	}
	return NewInvalidAndroidVersionError(err)
}

func NewInvalidAndroidDeviceError(err error) error {

	return InvalidAndroidDeviceError{ Err: err, Stack: callers() }

}

func WrapInvalidAndroidDeviceError(err error) error {
	if err == nil {
		return nil
	}
	return NewInvalidAndroidDeviceError(err)
}

func NewInvalidIOSDeviceError(err error) error {

	return InvalidIOSDeviceError{ Err: err, Stack: callers() }

}

func WrapInvalidIOSDeviceError(err error) error {
	if err == nil {
		return nil
	}
	return NewInvalidIOSDeviceError(err)
}

func (e DebugErrorOneError) Error() string {
    return "DBGAAAAAAAB"
}

func (e DebugErrorOneError) Unwrap() error {
	return e.Err
}

func (e DebugErrorOneError) Is(target error) bool {
    t, ok := target.(DebugErrorOneError)
    if !ok {
        return false
    }
    return t.Prefix() == "DBG" && t.Code() == 1
}

func (e DebugErrorOneError) Code() int {
    return 1
}

func (e DebugErrorOneError) Description() string {
    return "The first debug error"
}

func (e DebugErrorOneError) Prefix() string {
    return "DBG"
}

func (e DebugErrorOneError) String() string {
   return "DBGAAAAAAAB The first debug error"
}

func (e DebugErrorOneError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "DBGAAAAAAAB")
	case 'q':
		fmt.Fprintf(s, "%q", "DBGAAAAAAAB")
	}
}

func (e DebugErrorTwoError) Error() string {
    return "DBGAAAAAAAC"
}

func (e DebugErrorTwoError) Unwrap() error {
	return e.Err
}

func (e DebugErrorTwoError) Is(target error) bool {
    t, ok := target.(DebugErrorTwoError)
    if !ok {
        return false
    }
    return t.Prefix() == "DBG" && t.Code() == 2
}

func (e DebugErrorTwoError) Code() int {
    return 2
}

func (e DebugErrorTwoError) Description() string {
    return "The second debug error"
}

func (e DebugErrorTwoError) Prefix() string {
    return "DBG"
}

func (e DebugErrorTwoError) String() string {
   return "DBGAAAAAAAC The second debug error"
}

func (e DebugErrorTwoError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "DBGAAAAAAAC")
	case 'q':
		fmt.Fprintf(s, "%q", "DBGAAAAAAAC")
	}
}

func (e DebugErrorThreeError) Error() string {
    return "DBGAAAAAAAG"
}

func (e DebugErrorThreeError) Unwrap() error {
	return e.Err
}

func (e DebugErrorThreeError) Is(target error) bool {
    t, ok := target.(DebugErrorThreeError)
    if !ok {
        return false
    }
    return t.Prefix() == "DBG" && t.Code() == 6
}

func (e DebugErrorThreeError) Code() int {
    return 6
}

func (e DebugErrorThreeError) Description() string {
    return "The third debug error"
}

func (e DebugErrorThreeError) Prefix() string {
    return "DBG"
}

func (e DebugErrorThreeError) String() string {
   return "DBGAAAAAAAG The third debug error"
}

func (e DebugErrorThreeError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "DBGAAAAAAAG")
	case 'q':
		fmt.Fprintf(s, "%q", "DBGAAAAAAAG")
	}
}

func (e InvalidAndroidVersionError) Error() string {
    return "MOBANDAAAAAAAE"
}

func (e InvalidAndroidVersionError) Unwrap() error {
	return e.Err
}

func (e InvalidAndroidVersionError) Is(target error) bool {
    t, ok := target.(InvalidAndroidVersionError)
    if !ok {
        return false
    }
    return t.Prefix() == "MOBAND" && t.Code() == 4
}

func (e InvalidAndroidVersionError) Code() int {
    return 4
}

func (e InvalidAndroidVersionError) Description() string {
    return "The Android version is invalid."
}

func (e InvalidAndroidVersionError) Prefix() string {
    return "MOBAND"
}

func (e InvalidAndroidVersionError) String() string {
   return "MOBANDAAAAAAAE The Android version is invalid."
}

func (e InvalidAndroidVersionError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "MOBANDAAAAAAAE")
	case 'q':
		fmt.Fprintf(s, "%q", "MOBANDAAAAAAAE")
	}
}

func (e InvalidAndroidDeviceError) Error() string {
    return "MOBANDAAAAAAAF"
}

func (e InvalidAndroidDeviceError) Unwrap() error {
	return e.Err
}

func (e InvalidAndroidDeviceError) Is(target error) bool {
    t, ok := target.(InvalidAndroidDeviceError)
    if !ok {
        return false
    }
    return t.Prefix() == "MOBAND" && t.Code() == 5
}

func (e InvalidAndroidDeviceError) Code() int {
    return 5
}

func (e InvalidAndroidDeviceError) Description() string {
    return "The Android device is invalid."
}

func (e InvalidAndroidDeviceError) Prefix() string {
    return "MOBAND"
}

func (e InvalidAndroidDeviceError) String() string {
   return "MOBANDAAAAAAAF The Android device is invalid."
}

func (e InvalidAndroidDeviceError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "MOBANDAAAAAAAF")
	case 'q':
		fmt.Fprintf(s, "%q", "MOBANDAAAAAAAF")
	}
}

func (e InvalidIOSDeviceError) Error() string {
    return "MOBIOSAAAAAAAD"
}

func (e InvalidIOSDeviceError) Unwrap() error {
	return e.Err
}

func (e InvalidIOSDeviceError) Is(target error) bool {
    t, ok := target.(InvalidIOSDeviceError)
    if !ok {
        return false
    }
    return t.Prefix() == "MOBIOS" && t.Code() == 3
}

func (e InvalidIOSDeviceError) Code() int {
    return 3
}

func (e InvalidIOSDeviceError) Description() string {
    return "The iOS device is invalid."
}

func (e InvalidIOSDeviceError) Prefix() string {
    return "MOBIOS"
}

func (e InvalidIOSDeviceError) String() string {
   return "MOBIOSAAAAAAAD The iOS device is invalid."
}

func (e InvalidIOSDeviceError)  Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", e.Unwrap())
			e.Stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, "MOBIOSAAAAAAAD")
	case 'q':
		fmt.Fprintf(s, "%q", "MOBIOSAAAAAAAD")
	}
}


// Frame represents a program counter inside a stack frame.
// For historical reasons if Frame is interpreted as a uintptr
// its value represents the program counter + 1.
type Frame uintptr

// pc returns the program counter for this frame;
// multiple frames may have the same PC value.
func (f Frame) pc() uintptr { return uintptr(f) - 1 }

// file returns the full path to the file that contains the
// function for this Frame's pc.
func (f Frame) file() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	file, _ := fn.FileLine(f.pc())
	return file
}

// line returns the line number of source code of the
// function for this Frame's pc.
func (f Frame) line() int {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return 0
	}
	_, line := fn.FileLine(f.pc())
	return line
}

// name returns the name of this function, if known.
func (f Frame) name() string {
	fn := runtime.FuncForPC(f.pc())
	if fn == nil {
		return "unknown"
	}
	return fn.Name()
}

// Format formats the frame according to the fmt.Formatter interface.
//
//    %s    source file
//    %d    source line
//    %n    function name
//    %v    equivalent to %s:%d
//
// Format accepts flags that alter the printing of some verbs, as follows:
//
//    %+s   function name and path of source file relative to the compile time
//          GOPATH separated by \n\t (<funcname>\n\t<path>)
//    %+v   equivalent to %+s:%d
func (f Frame) Format(s fmt.State, verb rune) {
	switch verb {
	case 's':
		switch {
		case s.Flag('+'):
			io.WriteString(s, f.name())
			io.WriteString(s, "\n\t")
			io.WriteString(s, f.file())
		default:
			io.WriteString(s, path.Base(f.file()))
		}
	case 'd':
		io.WriteString(s, strconv.Itoa(f.line()))
	case 'n':
		io.WriteString(s, funcname(f.name()))
	case 'v':
		f.Format(s, 's')
		io.WriteString(s, ":")
		f.Format(s, 'd')
	}
}

// MarshalText formats a stacktrace Frame as a text string. The output is the
// same as that of fmt.Sprintf("%+v", f), but without newlines or tabs.
func (f Frame) MarshalText() ([]byte, error) {
	name := f.name()
	if name == "unknown" {
		return []byte(name), nil
	}
	return []byte(fmt.Sprintf("%s %s:%d", name, f.file(), f.line())), nil
}

// StackTrace is stack of Frames from innermost (newest) to outermost (oldest).
type StackTrace []Frame


// Format formats the stack of Frames according to the fmt.Formatter interface.
//
//    %s	lists source files for each Frame in the stack
//    %v	lists the source file and line number for each Frame in the stack
//
// Format accepts flags that alter the printing of some verbs, as follows:
//
//    %+v   Prints filename, function, and line number for each Frame in the stack.
func (st StackTrace) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		switch {
		case s.Flag('+'):
			for _, f := range st {
				io.WriteString(s, "\n")
				f.Format(s, verb)
			}
		case s.Flag('#'):
			fmt.Fprintf(s, "%#v", []Frame(st))
		default:
			st.formatSlice(s, verb)
		}
	case 's':
		st.formatSlice(s, verb)
	}
}

// formatSlice will format this StackTrace into the given buffer as a slice of
// Frame, only valid when called with '%s' or '%v'.
func (st StackTrace) formatSlice(s fmt.State, verb rune) {
	io.WriteString(s, "[")
	for i, f := range st {
		if i > 0 {
			io.WriteString(s, " ")
		}
		f.Format(s, verb)
	}
	io.WriteString(s, "]")
}

// stack represents a stack of program counters.
type stack []uintptr

func (s *stack) Format(st fmt.State, verb rune) {
	switch verb {
	case 'v':
		switch {
		case st.Flag('+'):
			for _, pc := range *s {
				f := Frame(pc)
				fmt.Fprintf(st, "\n%+v", f)
			}
		}
	}
}

func (s *stack) StackTrace() StackTrace {
	f := make([]Frame, len(*s))
	for i := 0; i < len(f); i++ {
		f[i] = Frame((*s)[i])
	}
	return f
}

func callers() *stack {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(3, pcs[:])
	var st stack = pcs[0:n]
	return &st
}

// funcname removes the path prefix component of a function's name reported by func.Name().
func funcname(name string) string {
	i := strings.LastIndex(name, "/")
	name = name[i+1:]
	i = strings.Index(name, ".")
	return name[i+1:]
}

func ErrorChain(err error) []string {
	var results []string
	if err == nil {
		return results
	}
	depth := 0
	next := err
	for {
		if depth > 10 {
			break
		}
		results = append(results, next.Error())

		next = go_errors.Unwrap(next)
		if next == nil {
			break
		}

		depth = depth + 1
	}
	return results
}
